# CustomDictionary (Вариант 0: Самобалансирующееся дерево поиска)

Проект-заготовка для реализации словаря на C++ (ключ `int`, значение `std::string`) на базе самобалансирующегося дерева поиска (AVL). Включает сборку CMake, каркас бенчмарков и инструкции по измерениям на macOS (Apple Silicon, M1/M2).

## Установка инструментов

- Требуется: CMake (>= 3.20), Clang/LLVM, Xcode Command Line Tools, Python 3 (опционально для графиков).
- Установить инструменты (macOS):
  - Xcode CLT: `xcode-select --install`
  - CMake: `brew install cmake`
  - LLVM (опционально): `brew install llvm`

## Сборка

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
```

Таргеты:
- `dictionary_main` — исполняемый файл-заглушка
- `benchmarks` — исполняемый файл для бенчмарков (каркас)
- `unit_tests` — простейший smoke-тест

## Форматирование

Используется `.clang-format`. Запуск (пример):
```bash
clang-format -i $(git ls-files '*.hpp' '*.cpp')
```

## Бенчмарки: сценарии

Будут реализованы три сценария на входных данных:
- Оптимальный: случайные ключи, сбалансированная высота дерева
- Худший: монотонно возрастающие/убывающие ключи (проверка корректности балансировки)
- Случайный: равномерное рандомное распределение ключей

Операции: вставка (insert), добавление/обновление (upsert), удаление (erase).  
Метрики: распределение задержек (пер-операция), сводные статистики (p50/p95/p99), throughput.

## Измерение времени

- Для коротких операций используйте `std::chrono::steady_clock` и/или `mach_absolute_time` (CoreServices) при необходимости.
- Избегайте оптимизации мёртвого кода: результаты операций должны на что-то влиять (например, суммировать длины строк, считать хэш результата, печатать итоговую сводку).
- Прогрев: выполняйте «warmup» перед замерами.

## Сэмплирование и Flame Graph на macOS (Apple Silicon)

На macOS нет `perf`, используйте Instruments/xctrace:

1) Графический вариант (Instruments):
- Откройте Instruments (часть Xcode)
- Шаблон `Time Profiler`
- Запустите таргет `benchmarks` и соберите несколько секунд
- Просматривайте стеки, Flame Graph (Call Tree)

2) CLI вариант (xctrace):
```bash
./scripts/profile_xctrace.sh SECONDS_TO_RECORD=10 -- --dataset random --ops insert --n 100000
```
- Параметры после `--` передаются вашему бенчмарку.
- Будет создан файл `profile.trace`; откройте его в Instruments.

Альтернативы для текстовых репортов:
- `sample` (устаревший, но иногда полезен): `sample <pid> <seconds> -file out.txt`
- `instruments` (старый CLI) — заменён на `xctrace`.

## Отсечение внешних факторов

- Сборка в `Release`, без отладочных проверок.
- Выключите фоновые задачи, зафиксируйте питание (по возможности), закройте тяжёлые приложения.
- Прогревайте кэши перед основными замерами.
- Выполняйте несколько повторов, отчёт об ошибке/доверительный интервал.

## Генерация графиков

Рекомендуется собрать CSV с задержками по операциям и строить графики (Python/gnuplot):
- Python: `matplotlib`, `seaborn`, `pandas`
- Альтернатива: `gnuplot`

## Сравнение со стандартными структурами

Для справки можно добавить сравнение со `std::map` (красно-чёрное дерево) и `std::unordered_map` (хэш-таблица) на тех же сценариях.

## Планы реализации

- Реализовать `AVLTreeDictionary` (вставка/балансировка, удаление, поиск)
- Добавить генераторы данных для сценариев
- Реализовать бенчмарки с экспортом CSV
- Снять профили, найти узкие места, оптимизировать, повторить замеры

## Скрипты

- `scripts/run_bench.sh` — сборка и запуск `benchmarks`
- `scripts/profile_xctrace.sh` — запись трейс-файла Instruments (Time Profiler)

## Быстрый старт

```bash
./scripts/run_bench.sh
./scripts/profile_xctrace.sh SECONDS_TO_RECORD=5 -- --dataset random --ops insert --n 10000
```
